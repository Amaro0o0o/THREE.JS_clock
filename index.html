<!DOCTYPE html>
<html lang="en">
<head>
    <title>Three.js Clock Animation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=1, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

const isMobile = window.matchMedia("(pointer: coarse)").matches ||
                 /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);

let scene, camera, renderer, clock, stats;
let perspectiveCamera, orthoCamera, activeCamera;
let sounds = {};
let controls;
let mixers = {};
let skeletons = {};
let allAnimations = [];
let gltfAnimations = [];
let tickSound;

init();
animate();

function scheduleAnimation() {
    let prevTime = null;

    function updateDigitAnimation() {
        const now = new Date();
        const minutes = now.getMinutes();
        const hours = now.getHours();

        const newDigits = [
            Math.floor(hours / 10),
            hours % 10,
            Math.floor(minutes / 10),
            minutes % 10
        ];

        if (!prevTime) {
            prevTime = newDigits;
            newDigits.forEach((digit, index) => {
                updateClockAnimationForMesh(`MESH${index + 1}`, digit);
            });
        } else {
            newDigits.forEach((digit, index) => {
                if (digit !== prevTime[index]) {
                    updateClockAnimationForMesh(`MESH${index + 1}`, digit);
                }
            });
            prevTime = newDigits;
        }

        console.log("Running updateDigitAnimation at:", now.toLocaleTimeString());
    }

    updateDigitAnimation(); // Run immediately on load

    const now = new Date();
    const delay = (60 - now.getSeconds()) * 1000 - now.getMilliseconds();

    setTimeout(() => {
        setInterval(updateDigitAnimation, 60 * 1000); // Only run every full minute
    }, delay);
}

function init() {
    scene = new THREE.Scene();

    if (isMobile) {
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    } else {
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    }

    camera.position.set(0, 1, 5);
    scene.background = null;

    renderer = new THREE.WebGLRenderer({ antialias: true,
        alpha: true, 
     });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.enableZoom = false;
    controls.enablePan = false;
    controls.update();

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x8d8d8d, 3);
    scene.add(hemiLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 3);
    dirLight.position.set(3, 10, 10);
    scene.add(dirLight);

    clock = new THREE.Clock();

    // Load 3D model
    const loader = new GLTFLoader();
    const modelPath = new URL('./models/gltf/learning1.glb', import.meta.url);
    loader.load(modelPath.href, function (gltf) {
        const model = gltf.scene;
        scene.add(model);
        gltfAnimations = gltf.animations;

        model.traverse((object) => {
            if (object.isSkinnedMesh) {
                const skeletonName = object.parent.name;
                if (!skeletons[skeletonName]) {
                    skeletons[skeletonName] = new THREE.SkeletonHelper(object);
                    scene.add(skeletons[skeletonName]);
                }
                if (!mixers[skeletonName]) {
                    mixers[skeletonName] = new THREE.AnimationMixer(object);
                }
            }
        });

        const aspect = window.innerWidth / window.innerHeight;

        perspectiveCamera = new THREE.PerspectiveCamera(45, aspect, 1, 100);
        perspectiveCamera.position.set(0, 1, 5.5);

        const frustumSize = 5;
        orthoCamera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            100
        );

        const listener = new THREE.AudioListener();
        camera.add(listener);

        const soundLoader = new THREE.AudioLoader();
        tickSound = new THREE.Audio(listener);
        soundLoader.load(`./sounds/tick.mp3`, function(buffer) {
            tickSound.setBuffer(buffer);
            tickSound.setVolume(0.5);
            console.log("Tick sound loaded");
        });

        orthoCamera.position.set(0, 1, 5);
        orthoCamera.lookAt(0, 1, 0);

        activeCamera = perspectiveCamera;
        controls.object = activeCamera;
        controls.update();
        controls.enableRotate = false;

        setupAnimations();
     
        scheduleAnimation(); // âœ… fixed lag issue

        fetchAndLogTimezones();
        
        setInterval(updateClockDisplay, 60000);
    });

    window.addEventListener('resize', onWindowResize);
}

function getCurrentTime() {
    const now = new Date();
    return `${String(now.getHours()).padStart(2,'0')}:${String(now.getMinutes()).padStart(2,'0')}`;
}

function updateClockAnimationForMesh(skeletonName, digit){
    let digitName = ["zero","one","two","three","four","five","six","seven","eight","nine"][digit];
    let clip = gltfAnimations.find(anim => anim.name.includes(digitName));

    if(clip && mixers[skeletonName]){
        let mixer = mixers[skeletonName];
        mixer.stopAllAction();
        let action = mixer.clipAction(clip);
        action.reset();
        action.setLoop(THREE.LoopOnce);
        action.clampWhenFinished = true;
        action.play();

        if(tickSound && tickSound.isPlaying) tickSound.stop();
        if(tickSound && tickSound.buffer) tickSound.play();
    }
}

function setupAnimations() {
    gltfAnimations.forEach((clip) => {
        let skeletonName = ["MESH1","MESH2","MESH3","MESH4"].find(n => clip.name.includes(n));
        if(skeletonName && mixers[skeletonName]){
            let action = mixers[skeletonName].clipAction(clip);
            action.play();
            if(!allAnimations[skeletonName]) allAnimations[skeletonName] = [];
            allAnimations[skeletonName].push(action);
        }
    });
}

function onWindowResize() {
    const aspect = window.innerWidth / window.innerHeight;
    activeCamera.aspect = aspect;
    activeCamera.updateProjectionMatrix();

    if(orthoCamera){
        const frustumSize = 5;
        orthoCamera.left = -frustumSize * aspect / 2;
        orthoCamera.right = frustumSize * aspect / 2;
        orthoCamera.top = frustumSize / 2;
        orthoCamera.bottom = -frustumSize / 2;
        orthoCamera.updateProjectionMatrix();
    }

    if(window.innerWidth < 768){
        camera.fov = 55;
        camera.position.set(-1.5, 2.5, 4);
    } else {
        camera.fov = 45;
        camera.position.set(-1, 2, 3);
    }

    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    Object.values(mixers).forEach(m => m.update(delta));
    renderer.render(scene, activeCamera);
}
</script>
</body>
</html>
